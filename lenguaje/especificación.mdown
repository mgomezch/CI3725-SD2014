% Trinity
% Especificación del lenguaje
% Borrador 1 — \today

- - -

# Introducción

*Esta sección es informativa.*

1.  Este documento define el lenguaje de programación *Trinity* y especifica requerimientos para sus implantaciones.

2.  *Trinity* es un lenguaje de programación imperativo con alcance y tipos estáticos enfocado en conceptos básicos de álgebra lineal sobre los números reales, y con soporte directo para operaciones entre escalares, vectores y matrices.  Su influencia principal es el lenguaje [*Octave*](http://www.gnu.org/software/octave/).

3.  Este documento describe el lenguaje de programación *Trinity* a través de los elementos fundamentales de todo lenguaje: sus **objetos**, sus mecanismos de **composición** para hacer objetos complejos a partir de otros simples, y sus mecanismos de **abstracción y control**.  No se presenta una gramática exacta para el lenguaje ni una especificación formal de su semántica, pero sí se especifica lo necesario para construir una gramática y un intérprete.




# Especificación

*Esta sección es normativa.*



## Objetos

1.  Las expresiones `false` y `true` en *Trinity* denotan los dos únicos valores con el tipo booleano, cuya especificación de tipo es `boolean`.  Los dos son iguales a sí mismos y distintos entre sí.  Los lexemas `boolean`, `false` y `true` son palabras reservadas.

2.  Las cantidades escalares en *Trinity* corresponden al tipo numérico, cuya especificación de tipo es `number`, y se implementan como números de punto flotante según el estándar [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point), incluyendo a la noción de igualdad.  El lexema `number` es una palabra reservada.

3.  Un literal numérico está formado por secuencias de dígitos en notación posicional decimal, con una parte fraccional opcional separada por un punto (`.`) de la parte entera.  Por ejemplo, `42` y [`6.2831853`](http://www.tauday.com/) son literales numéricos.  Los literales numéricos son expresiones que denotan cantidades escalares y tienen el tipo numérico.

4.  Las cantidades matriciales en *Trinity* son arreglos bidimensionales, rectangulares, discretos y finitos de cantidades escalares.  Las cantidades matriciales de `n` filas y `m` columnas corresponden al tipo especificado por `matrix(n, m)`.  Dos cantidades matriciales del mismo tipo se consideran iguales cuando las cantidades escalares correspondientes en cada posición son iguales.  El lexema `matrix` es una palabra reservada.

5.  Las cantidades vectoriales son cantidades matriciales de una sola fila o una sola columna.  Los vectores fila de `m` dimensiones tienen el tipo especificado por `row(m)`, y los vectores columna de `n` dimensiones tienen el tipo especificado por `col(n)`.  `col(n)` y `row(m)` denotan los mismos tipos que `matrix(n, 1)` y `matrix(1, m)`, respectivamente — son simples atajos en la notación, y no representan conceptos distintos.  Los lexemas `row` y `col` son palabras reservadas.

6.  Un literal matricial es una secuencia de filas separadas por el símbolo dos puntos (`:`) y encerrada toda entre corchetes curvos (`{` y `}`), siendo cada fila una secuencia de igual número de expresiones separadas por el símbolo coma (`,`), cada una de las cuales debe tener el tipo numérico.  Los literales matriciales son expresiones que denotan cantidades matriciales y tienen el tipo especificado por `matrix(n, m)`, donde `n` es el número de filas en el literal matricial, y `m` el número de expresiones en cada una de las filas.

    Por ejemplo,

        { 1, 2, 3 }

    es un literal matricial y denota un valor con el tipo especificado por `matrix(1, 3)`, que también puede escribirse `row(3)`, y

        { 4, 5 : 6, 7 : 8, 9 }

    es otro literal matricial y denota un valor con el tipo especificado por `matrix(3, 2)`.

7.  Los tipos de las cantidades escalares y matriciales se denominan *tipos aritméticos*.

8.  El tipo especificado por `matrix(1, 1)` **no** se considera equivalente al tipo numérico.  Por ejemplo, las expresiones `42` y `{ 42 }` no tienen el mismo tipo, ya que la primera es del tipo numérico y la segunda es del tipo especificado por `matrix(1, 1)`.  Como no son del mismo tipo, ni siquiera pueden considerarse iguales ni distintas.



## Composición

1.  A partir de una expresión `e` de cualquier tipo, se puede formar la expresión `(e)` del mismo tipo, cuyo valor será el valor de `e`.  Por ejemplo, `42`, `(42)` y `((42))` son expresiones que valen lo mismo, al igual que `true` y `(true)`, y al igual que `{ 1, 2, 3 }` y `({ 1, (2), ((3)) })`.  La evaluación de `(e)` procede con la evaluación de `e`, y al ésta producir su valor, se calcula y produce el resultado correspondiente, que en este caso es el mismo.  Esta forma de evaluación será referida en el resto de este documento como «estricta».


### Operadores lógicos

1.  A partir de una expresión `e` del tipo booleano, se puede formar la expresión `not e` del tipo booleano, cuyo valor será el contrario del valor de `e`.  La evaluación de `not e` es estricta.  El lexema `not` es una palabra reservada.

    Por ejemplo,

        not true

    es una expresión del tipo booleano y tiene el mismo valor que la expresión `false`.

2.  A partir de dos expresiones `e`~1~ y `e`~2~ del tipo booleano, se pueden formar las expresiones `e₁ & e₂` y `e₁ | e₂`, ambas del tipo booleano, cuyos valores serán, respectivamente, la conjunción y la disyunción de los valores de `e`~1~ y `e`~2~.  Ambos operadores tienen asociatividad izquierda y tienen menor precedencia que el operador `not`.  El operador `&` tiene mayor precedencia que el operador `|`.

    Por ejemplo, la expresión

        false & true | true

    es del tipo  booleano y tiene el mismo valor que la expresión

        (false & true) | true

    debido a que la precedencia de `&` es mayor que la de `|`.

3.  La evaluación de `e₁ & e₂` procede con la evaluación de `e`~1~, y si ésta produce el valor `false`, la evaluación de `e₁ & e₂` produce `false` de inmediato, sin evaluar `e`~2~; si, en cambio, la evaluación de `e`~1~ produce el valor `true`, entonces se evalúa `e`~2~ y la evaluación de `e₁ & e₂` produce finalmente el valor que produce la evaluación de `e`~2~.

4.  La evaluación de `e₁ | e₂` procede con la evaluación de `e`~1~, y si ésta produce el valor `true`, la evaluación de `e₁ | e₂` produce `true` de inmediato, sin evaluar `e`~2~; si, en cambio, la evaluación de `e`~1~ produce el valor `false`, entonces se evalúa `e`~2~ y la evaluación de `e₁ | e₂` produce finalmente el valor que produce la evaluación de `e`~2~.

5.  A partir de dos expresiones `e`~1~ y `e`~2~ del mismo tipo cualquiera[^homoeq], se pueden formar las expresiones `e₁ == e₂` y `e₁ /= e₂`, ambas del tipo booleano, cuyos valores serán, respectivamente, `true` y `false` si los valores de `e`~1~ y `e`~2~ son iguales. Ninguno de los dos operadores es asociativo y ambos tienen igual precedencia.

    Por ejemplo, las siguientes expresiones tienen el mismo valor que la expresión `true`:

        2 /= 4

        true == not false

        { 1, 2 : 3, 4 } /= { 3, 4 : 1, 2 }

6.  La evaluación de `e₁ == e₂` y `e₁ /= e₂` procede con la evaluación de `e`~1~; al terminarla, procede a evaluar `e`~2~; al terminarla, verifica si ambos valores producidos por las subexpresiones son iguales, y produce el resultado final.  El mecanismo de evaluación análogo para expresiones formadas por otros operadores binarios será referido en el resto de este documento como estricta de izquierda a derecha.

[^homoeq]: La igualdad en *Trinity* es homogénea.  No se puede formar una expresión con los operadores `==` y `/=` entre dos expresiones con tipos diferentes.  Por lo tanto, dos valores de tipos diferentes no pueden compararse entre sí ni siquiera para resultar en que son distintos.  La forma `42 == { 54 }` **no** es una expresión con valor `false`, sino un fragmento de programa mal formado que debe arrojar un error estáticamente.

7.  A partir de dos expresiones `e`~1~ y `e`~2~ del tipo numérico, se pueden formar las expresiones `e₁ <= e₂`, `e₁ < e₂`, `e₁ >= e₂` y `e₁ > e₂`, todas del tipo booleano, cuyos valores serán `true` únicamente si el valor de `e`~1~ es, respectivamente, menor or igual, menor, mayor o igual o mayor que el valor de `e`~2~.  Ninguno de los cuatro operadores es asociativo y todos tienen precedencia igual a la de `==` y `/=`.  La evaluación de estas expresiones es estricta de izquierda a derecha.

    Por ejemplo, la siguiente expresión tiene el mismo valor que la expresión `true`:

        4 <= 4 & 2 < 4 & 4 >= 2 & 4 > 2


### Operadores aritméticos

1.  A partir de dos expresiones `e`~1~ y `e`~2~ de un mismo tipo aritmético, se pueden formar las expresiones `e₁ + e₂` y `e₁ - e₂`, ambas del mismo tipo aritmético original, cuyos valores serán, respectivamente, la suma y la resta de los valores de `e`~1~ y `e`~2~.  Ambos operadores tienen asociatividad izquierda y tienen igual precedencia.  La evaluación de estas expresiones es estricta de izquierda a derecha.

    Por ejemplo, las siguientes expresiones tienen el mismo valor que la expresión `true`:

        2 + 4 == 6

        { 1, 2 } + { 2, 1 } == { 3, 3 }

2.  A partir de una expresión `e` de un tipo aritmético, se puede formar la expresión `- e` del mismo tipo, cuyo valor será el inverso aditivo de `e`.  Por ejemplo, `- (3 * (- 3)) == 9`.  La evaluación de `- e` es estricta.

3.  A partir de expresiones `e`~1~ del tipo especificado por `matrix(n, m)` y `e`~2~ del tipo especificado por `matrix(m, p)`, se puede formar la expresión `e₁ * e₂` del tipo especificado por `matrix(n, p)`, cuyo valor se calculará como el producto matricial de los valores de `e`~1~ y `e`~2~.  Por otra parte, a partir de expresiones `e`~1~ y `e`~2~ del tipo numérico, se puede formar la expresión `e₁ * e₂` del tipo numérico, cuyo valor será el producto (escalar) de los valores de `e`~1~ y `e`~2~.  El operador `*` tiene asociatividad izquierda y mayor precedencia que los operadores `+` y `-`.  La evaluación de estas expresiones es estricta de izquierda a derecha.

    Por ejemplo, las siguientes expresiones tienen el mismo valor que la expresión `true`:

        { 1, 2, 3 } * { 1 : 2 : 3 } == { 14 }

        2 * 3 == 6

4.  A partir de expresiones `e`~1~ y `e`~2~ del tipo numérico, se pueden formar las expresiones `e₁ / e₂` y `e₁ % e₂`, ambas del tipo numérico, cuyos valores serán, respectivamente, la división exacta y el resto exacto de la división entera entre los valores de `e`~1~ y `e`~2~.  Los operadores `/` y `%` tienen asociatividad izquierda y ambos tienen la misma precedencia que el operador `*`.  La evaluación de estas expresiones es estricta de izquierda a derecha.

    Por ejemplo, las siguientes expresiones tienen el mismo valor que la expresión `true`:

        5 / 2 == 2.5

        10.2 % 2 == 0.2

5.  A partir de expresiones `e`~1~ y `e`~2~ del tipo numérico, se pueden formar las expresiones `e₁ div e₂` y `e₁ mod e₂`, ambas del tipo numérico, cuyos valores serán, respectivamente, la división entera y el resto entero de la división entre los valores de `e`~1~ y `e`~2~.  Los operadores `div` y `mod` tienen asociatividad izquierda y ambos tienen la misma precedencia que el operador `*`.  La evaluación de estas expresiones es estricta de izquierda a derecha.  Los lexemas `div` y `mod` son palabras reservadas.

    Por ejemplo, las siguientes expresiones tienen el mismo valor que la expresión `true`:

        5 div 2 == 2

        10.2 mod 2 == 0

6.  A partir de una expresión `e` del tipo especificado `matrix(n, m)`, se puede formar la expresión `e'` del tipo especificado por `matrix(m, n)`, cuyo valor será la traspuesta del valor de `e`.  El operador `'` tiene mayor precedencia que el operador `*`.  La evaluación de estas expresiones es estricta.

    Por ejemplo,

        { 1, 2, 3 : 4, 5, 6 }'

    es una expresión del tipo especificado por `matrix(3, 2)` y su valor es igual al de la expresión

        { 1, 4 : 2, 5 : 3, 6 }

7.  Todos los operadores aritméticos tienen mayor precedencia que todos los operadores lógicos.


### Operadores cruzados

1.  *Trinity* soporta operaciones cruzadas entre cantidades escalares y matriciales.  Estas operaciones aplican a cada elemento de una cantidad matricial una misma operación con una cantidad escalar.

2.  Cada operador binario entre cantidades escalares que resulte en otra cantidad escalar tiene un operador cruzado correspondiente.  Los operadores cruzados `.+.`, `.-.`, `.*.`, `./.`, `.%.`, `.div.` y `.mod.` corresponden a los operadores escalares `+`, `-`, `*`, `/`, `%`, `div` y `mod`, respectivamente.

3.  A partir de expresiones `e`~1~ del tipo numérico y `e`~2~ de un tipo matricial, y para cada operador cruzado `.op.`, se pueden formar las expresiones `e₁ .op. e₂` y `e₂ .op. e₁` del mismo tipo de `e`~2~, cuyos valores son la cantidad matricial obtenida al sustituir cada componente `xᵤᵥ` de `e`~2~ por `e₁ op xᵤᵥ` o `xᵤᵥ op e₁`, respectivamente, donde `op` es el operador escalar correspondiente de `.op.`.  La evaluación de estas expresiones es estricta de izquierda a derecha.

4.  Por ejemplo,

        { 1, 2, 3 } .*. 10

    es una expresión del tipo especificado por `matrix(2, 3)` y su valor es igual al de la expresión

        { 1*10, 2*10, 3*10 }

    De igual manera,

        12 ./. { 2, 3 : 4, 8 }

    es una expresión del tipo especificado por `matrix(2, 2)` y su valor es igual al de la expresión

        { 6, 4 : 3, 1.5 }


### Proyección de componentes

1.  A partir de una expresión `e` del tipo especificado por `matrix(n, m)`, y dos expresiones `i` y `j` del tipo numérico, se puede formar la expresión `e[i, j]` del tipo numérico, cuyo valor será la componente del valor de `e` en la fila cuyo índice sea el valor de la expresión `i`, y en la columna cuyo índice sea el valor de la expresión `j`.  Esta operación tiene la máxima precedencia.

2.  La evaluación de `e[i, j]` sigue los siguientes pasos:

    1.  Se procede con la evaluación de `e`.

    2.  Una vez terminada y producido su valor, se procede con la evaluación de `i`.

    3.  Una vez terminada y producido su valor, se verifica si ese valor es un entero entre 1 y el número de filas del tipo de la expresión `e`.

    4.  Si esta condición no se cumple, la ejecución del programa abortará.  Si la condición sí se cumple, se procede con la evaluación de `j`.

    6.  Una vez terminada y producido su valor, se verifica si ese valor es un entero entre 1 y el número de columnas del tipo de la expresión `e`.

    7.  Si esta condición no se cumple, la ejecución del programa abortará.  Si la condición sí se cumple, se produce como resultado final de la evaluación de `e[i, j]` el valor en la posición del valor producido al evaluar `e` en la fila y la columna dadas por los valores producidos al evaluar `i` y `j`.

3.  Por ejemplo, la expresión

        { 1, 2 : 3, 4 }[1 + 1, 2 - 1]

    tiene el mismo valor que la expresión `3`.

<!-- TODO: proyección de componentes con una sola dimensión, para vectores -->



## Abstracción y control

1.  *Trinity* es un lenguaje imperativo, y su mecanismo principal de operación es la ejecución de secuencias de instrucciones.  Algunas instrucciones son estructuras de control que pueden contener otras secuencias de instrucciones que se ejecuten de manera condicional o reiterada.

2.  A partir de una o más instrucciones `i`~1~, `i`~2~, …, `i`~n~, se puede formar una secuencia de instrucciones `i`~1~ `i`~2~ … `i`~n~ simplemente escribiéndolas en secuencia.

3.  A partir de una expresión `e` de cualquier tipo, se puede formar la instrucción `e;`.  La ejecución de esta instrucción procede con la evaluación de `e` y descarta su valor.


### Impresión

1.  A partir de expresiones `e`~1~, `e`~2~. …, `e`~n~ de tipos cualesquiera, o literales de cadena de caracteres, se puede formar la instrucción `print e`~1~`, e`~2~` … e`~n~`;`.  La ejecución de esta instrucción procede con la evaluación de `e`~1~, `e`~2~ … `e`~n~ en el orden de aparición, exceptuando aquellas que no sean expresiones sino literales de cadena de caracteres,  y al todas haber producido sus valores, se escribe a la salida estándar del programa una representación textual de los valores obtenidos, o el texto representado por los literales de cadena de caracteres, en el mismo orden de aparición.  El lexema `print` es una palabra reservada.

    Por ejemplo,

        print { 1, 2, 3 }, 4.5;

    es una instrucción de impresión.

2.  La instrucción de impresión **no imprime un salto de línea** después de haber impreso la lista completa de argumentos, ni entre la impresión correspondiente a cada uno de sus argumentos.

3.  En un literal de cadena de caracteres, el caracter *backslash* solo puede ocurrir como parte de una secuencia de escape.  Una secuencia de escape es un caracter *backslash* seguido de una `n` (`\n`), otro *backslash* (`\\`), o una comilla doble (`\"`).  Una secuencia de escape representa texto: `\n` representa un fin de línea, `\\` representa un caracter *backslash*, y `\"` representa una comilla doble.

4.  Un literal de cadena de caracteres es una secuencia de caracteres encerrada entre comillas dobles (`"`) y que no contiene fines de linea ni comillas dobles, salvo como parte de una secuencia de escape.  Las comillas dobles que delimitan a un literal de cadena de caracteres no pueden ser parte de una secuencia de escape.  El texto representado por un literal de cadena de caracteres es el mismo texto que lo compone, sin sus delimitadores, y sustituyendo las secuencias de escape por el texto que representan.

4.  Por ejemplo, al ejecutarse la instrucción de impresión

        print "Hello world!\nA string inside a string: \"this is so \\meta\""

    el programa escribirá esto a su salida estándar:

        Hello world!
        A string inside a string: "this is so \meta"


### Variables y alcances

1.  *Trinity* utiliza alcance estático y requiere que las variables sean declaradas con sus tipos antes de poder usarse o asignarse.  Esta sección define con precisión el funcionamiento del alcance de las variables en el lenguaje.

2.  Un identificador es una secuencia de caracteres no vacía compuesta por letras de la `A` hasta la `Z` (minúscula o mayúscula), los dígitos del `0` al `9` y el caracter *underscore* (`_`).  Los identificadores deben comenzar por letras, no pueden comenzar ni por dígitos ni por `_`, y son sensibles a mayúsculas; por ejemplo, el identificador `foo` es distinto del identificador `fOo`.  Además de estas restricciones, aquellas secuencias de caracteres que sean palabras reservadas no son identificadores.

    Por ejemplo, `print` y `not` no son identificadores, porque son palabras reservadas, pero `pRint` sí es un identificador.

3.  No es necesario que se reconozcan letras con tildes ni la letra eñe — *Trinity* solo requiere identificadores hechos de caracteres imprimibles definidos por el estándar ASCII<!-- TODO: reference -->.

4.  Una variable es una ubicación de memoria modificable que hace referencia a un valor.  Pueden hacerse disponibles variables en las instrucciones contenidas directa o indirectamente en una secuencia de instrucciones particular, así como en las expresiones que éstas contengan.  Para hacerlo, la secuencia de instrucciones se incluye en una instrucción de bloque que declare esa variable y la asocie a un nombre.  Las instrucciones incluidas en ese bloque, y las expresiones que contengan, podrán referirse a la variable a través del nombre que se le asoció en el bloque donde fue declarada.

5.  A partir de un identificador `i`, una especificación de tipo `t` y una expresión `e` del tipo especificado por `t`, se puede formar una declaración de variable `t i;` o una declaración de variable con inicialización `t i = e;`.  A partir de una o más declaraciones `d`~1~, `d`~2~, …, `d`~n~, se puede formar una secuencia de declaraciones `d`~1~ `d`~2~ … `d`~n~ simplemente escribiéndolas en secuencia.

    Por ejemplo,

        matrix(9, 9) foo;

    es una declaración de variable para el identificador `foo` y el tipo `matrix(9, 9)` —y también una secuencia de declaraciones con una sola declaración—, y

        number i = 42; boolean b;
        row(5) F_5 = { 1, 1, 2, 3, 5 };

    es una secuencia de declaraciones en la cual hay dos declaraciones de variable con inicialización (las de los identificadores `i` y `F_5`), y una declaración de variable regular sin inicialización (la del identificador `b`).

6.  A partir de una secuencia de instrucciones `is` y una secuencia de declaraciones `ds`, se puede formar una instrucción de bloque `use ds in is end;`, si los identificadores en las declaraciones en `ds` no se repiten en la secuencia.

    Por ejemplo, esta es una instrucción de bloque:

        use
          number tau = 6.2831853;
          matrix(2, 2) m = { 4, 2 : 1, 1/2 };
        in
          print tau, m[2, 1]
        end;

7.  La secuencia de declaraciones en cada instrucción de bloque produce un contexto en el cual cada declaración hace disponible una variable del tipo de la declaración que se asocia al identificador de la declaración.  Ese contexto se extiende sobre todas las instrucciones y expresiones contenidas directa o indirectamente en la secuencia de instrucciones de la instrucción de bloque.  Si el alcance de un contexto de declaración ocurre dentro del alcance de otro, entonces en el alcance del contexto interior, la asociación de la declaración del contexto interior sustituye a la asociación de la declaración del contexto exterior si usa el mismo identificador.

    Por ejemplo, en la secuencia de instrucciones

        print 1;
        print 2;
        use
          number foo = 42;
          matrix(1, 1) bar;
        in
          print 3;
          print 4;
          use
            boolean foo;
          in
            print 5;
            print 6;
          end;
          print 7;
        end;
        print 8;
        print 9;

    Las tres declaraciones introducen regiones del programa donde hay identificadores asociados a tipos:

    *   Las instrucciones de impresión que imprimen 1, 2, 8 y 9 no están dentro de la extensión del contexto de ninguna declaración.

    *   Las instrucciones que imprimen 3, 4 y 7 están dentro de la extensión del contexto en el cual los identificadores `foo` y `bar` están asociados a un número y a una matriz, respectivamente.
:w

    *   Las instrucciones que imprimen 5 y 6 están dentro de la extensión del contexto antes mencionado, y también dentro de la extensión del contexto establecido por la declaración `boolean foo;`.

    Debido a la regla de sustitución, en el alcance del contexto interior (establecido por la declaración `boolean foo;`), la asociación del identificador `foo` con una variable de tipo booleano *sustituye* a la asociación del contexto exterior de `foo` con una variable de tipo numérico.  Esa sustitución *únicamente* aplica para las instrucciones que imprimen 5 y 6.

8.  A partir de un identificador `i`, puede utilizarse `i` como una expresión de uso de variable, que es de tipo `t`, en la extensión de un contexto producido por una declaración que asocie al identificador `i` con el tipo `t`.

    Por ejemplo, el programa

        use
          number foo = 10 + 5;
        in
          print foo + 27;
        end;

    está bien formado, porque el uso del identificador `foo` como una expresión de tipo numérico ocurre en la extensión del contexto establecido por la declaración `number foo = 10 + 5;`, que asocia el identificador `foo` a una variable de tipo numérico (y además le asocia el valor de la expresión `10 + 5`).

9.  Un programa en *Trinity* está mal formado si un identificador `i` se utiliza como expresión fuera de la extensión de un contexto de alguna declaración que asocie ese identificador con algún tipo.  En otras palabras: un identificador solo puede usarse como expresión en la extensión de su declaración.

    Por ejemplo,

        print 1;
        use
          number foor = 42;
        in
          print 2;
        end;
        print 3;
        print foor;
        print 5;

    es un programa mal formado, porque el uso del identificador `foor` como expresión ocurre fuera de la extensión del contexto establecido por la declaración.

10. Un programa en *Trinity* también está mal formado si un identificador `i` se utiliza como expresión en la extensión de un contexto de una declaración asocie ese identificador con algún tipo, pero que se use como expresión de un tipo distinto al asociado a `i` por la declaración con el contexto más interior que asocia a ese identificador con algún tipo en ese punto.  En otras palabras: un identificador solo puede usarse como expresión de un tipo en aquellas partes del programa donde la declaración más cercana de ese identificador lo asocie a ese mismo tipo.

    Por ejemplo,

        use
          boolean foo = true;
        in
          print 0 == foo;
        end;

    es un programa mal formado, porque aunque `foo` se usa como identificador dentro de la extensión del contexto establecido por una declaración que lo asocia a un tipo, se usa `foo` con el tipo numérico, pero está asociado al tipo booleano en la declaración relevante.


### Asignación, valores y referencias

1.  *Trinity* es un lenguaje imperativo con variables mutables por referencia.  Asignar a una variable hace que el valor asignado esté disponible al consultar la variable, y si una variable se asigna al valor de otra, ambas serán referencias al mismo valor compartido, así que las modificaciones hechas sobre una de las variables serán visibles usando la otra.  Además, las variables que no se inicialicen explícitamente son inicializadas con ceros.  Esta sección define con precisión el funcionamiento de la asignación en el lenguaje.

2.  A partir de un identificador `i` y una expresión `e` de tipo `t`, puede utilizarse la instrucción de asignación `i = e;` como instrucción en la extensión de un contexto producido por una declaración que asocie al identificador `i` con el tipo `t`.  La ejecución de esta instrucción procede con la evaluación de `e`, y al producir su valor, lo asocia al identificador `i` en toda la extensión de la asociación de la declaración correspondiente.

    Por ejemplo, en

        use
          boolean go = true;
        in
          while
            go
          do
            print 1;
            go = false & true;
            print 2;
          end;
        end;

    a pesar de que la condición del ciclo no está sintacticamente después de la asignación, sigue estando la condición dentro de la extensión del contexto establecido por la declaración, así que la asociación del valor computado de `false & true` (que es igual al de `false`) aplica para la condición del ciclo, por lo cual el cuerpo del ciclo solo es ejecutado una vez.

4.  Las declaraciones de variable con inicialización se comportan como asignaciones: ejecutar la instrucción donde ocurren ejecuta una asignación implícita al identificador de la declaración con la expresión dada en la inicialización.  Si hay varias declaraciones en una secuencia, las asignaciones de inicialización se ejecutan en el mismo orden en que ocurren en la secuencia.

    Por ejemplo, en

        use
          number p = 42;
          row(2) q = { 6, 7 };
        in
          use
            boolean r = q[p] == 0;
          in
            print "inalcanzable!"
          end;
        end;

    el programa aborta antes de imprimir, ya que se ejecuta la asignación `r = q[p] == 0`, lo cual evalúa la expresión `q[p] == 0`, que comienza por evaluar `q[r]`, pero `p` está asociada al valor de la expresión `42`, que sobrepasa los límites de la cantidad matricial de la cual se desea obtener un elemento..

5.  Las declaraciones de variable sin inicialización se comportan como declaraciones de variable con inicialización donde la expresión de inicialización es un literal del tipo apropiado con valores por defecto.  La inicialización por defecto para el tipo booleano es con el literal `false`, para el tipo numérico es con el literal `0`, y para tipos matriciales, es un literal matricial de las dimensiones adecuadas al tipo y con `0` en todas las componentes.

    Por ejemplo, <!-- TODO -->

6.  La ejecución de una instrucción de uso de variable con el identificador `i` produce como valor el último valor que se asociara a `i` en una instrucción de asignación, sea implícita o explícita.

    Por ejemplo, <!-- TODO -->

<!-- TODO: asignaciones a posiciones de matrices -->



- - -



0.  Las funciones de *Trinity* abstraen sobre secuencias de instrucciones, y permiten que éstas sean ejecutadas como parte de la evaluación de una expresión. <!-- TODO -->

El siguiente ejemplo es válido en *Trinity* y pone en evidencia las reglas de alcance:

    program
    begin
    use
        number x, y; # inicializados en 0
    in
        begin
        use
            row(3) x;
            col(3) y;
        in
            x = { 1 , 2 , 3 };
            y = { 1 : 2 : 3 };
            write "Write 1", x; # x será del tipo especificado por matrix(1,3)
        end;

        begin
        use
            boolean x, y;
        in
            x = true;
            write "Write 2", x; // x será de tipo bool
        end;

        write "Write 3", x; // x será de tipo int

        for x in { 1, 2, 3 : 4, 5, 6 } do
        begin
        use
            bool x; # esconde la x declarada en el for y se inicializa en 'false'
        in
            x = not x;
            write "Write 4", x; // x será de tipo bool
        end;
    end;



## Estructura de un programa

Un programa de *Trinity* tiene la siguiente estructura:

    program
    <instrucción> ;

Es decir, la palabra clave `program` seguida de una instrucción. Un programa simple de *Trinity* podría verse así:

    program begin
    use
        number x;
    in
        print "How old are you?\n> ";
        read x;

        if x < 18 then
            print "You can't be here.";
        else
            print "Oh, ", x, "? come right in.";
        end;
    end;

Que se correría así:

    $ ./trinity bouncer.ty
    How old are you?
    > 22
    Oh, 22? come right in.


## Instrucciones

### Entrada

    read <variable>;

Permite obtener entrada escrita para escalares por parte del usuario. Para ejecutar esta instrucción el interpretador debe solicitar al usuario que introduzca un valor, y posteriormente se debe validar y almacenar lo que sea introducido. Si la entrada es inválida debe arrojarse un error. Sólo se puede pedir entrada para variables de tipo numérico y booleano. Puede haber cualquier cantidad de espacio en blanco antes o después del dato introducido.

### Condicional `if then else`

    if <condición> then <instrucciones> else <instrucciones> end;
    if <condición> then <instrucciones> end;

La condición debe ser una expresión de tipo booleano, de lo contrario debe arrojarse un error.

Ejecutar está instrucción tiene el efecto de evaluar la condición y si su valor es `true` se ejecuta la `<instrucción 1>`; si su valor es `false` se ejecuta la `<instrucción 2>`. Es posible omitir la palabra clave `else` y la `<instrucción 2>` asociada, de manera que si la expresión vale `false` no se ejecuta ninguna instrucción.

### Iteración determinada

    for <identificador> in <vector/matrix> do <instrucciones> end;

Para ejecutar esta instrucción se evalúa la expresión `<vector/matrix>` que puede ser tanto una vector como una matriz, su tipo debe ser matricial, y a la variable `<identificador>` se le asigna cada valor dentro de la matriz, avanzando de izquierda a derecha y de arriba hacia abajo. Para cada valor de `<identificador>` se ejecuta `<instrucción>`. Note que cambiar el valor de la variable `<identificador>` **no cambiará el valor** de la posición representada por éste de la matriz.

La instrucción declara automáticamente una variable llamada `<identificador>` de tipo numérico y local al cuerpo de la iteración.

### Iteración indeterminada

    while <condición> do <instrucciones> end;

La condición debe ser una expresión de tipo booleano. Para ejecutar la `<instrucción>` se evalúa la `<condición>`, si es igual a `false` termina la iteración; si es `true` se ejecuta la `<instrucción>` del cuerpo y se repite el proceso.

    unless <condición> do <instrucciones> end;

Es equivalente a la instrucción de `while`, pero aplicando la *negación booleana* a la `<condición>`.

## Comentarios y espacion en blanco

    print "Hello World!" # esto es un comentario

En *Trinity* se pueden escribir comentarios de una línea, al estilo de Ruby. Al escribir `#` se ignorarán todos los caracteres hasta el siguiente salto de línea.

El espacio en blanco es ignorado de manera similar a otros lenguajes de programación, es decir, el programador es libre de colocar cualquier cantidad de espacio en blanco, saltos de línea, etc. entre los elementos sintácticos del lenguaje.

## Programas ejemplo

    program begin
    use
        matrix(2,2) m;  # se inicializa todas en '0'
        number x;       # se inicializa en '0'
        boolean b;      # se inicializa en 'false'
    in
        m = { 1, 2
            : 3 4 };

        read x;

        for i in m do
            if i % 2 == 0 then
                # si 'i' es par
                print i;
            else begin
                print x;
                read x;
                b = not b;
            end;
        end;

        if b then
            print i;
        else
            print "b is a lie";
        end;
    end;
